/***********************************************************************/
/*                                                                     */
/*  FILE        :MiconRacer2.c                                         */
/*  DATE        :Sat, Nov 14, 2015                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :34C                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include <stdlib.h>
#include "mr2_lib.h"

#pragma CREG	_flg_	flg
unsigned int	_flg_;

#define	INTG_MAX		(OPERATION_PERIOD/CONTROL_PERIOD)
int intg_log[INTG_MAX] = {};

int timer_flag;
int cont_flag;
int opr_flag;
int veh_flag;

int resp_intg;      // CONTROL_PERIOD区間の距離の積分値

int beep_time = 0;
#define BEEP_PERIOD()			do{ if( beep_time > 0 ){ beep_time--; }else{ beep( OFF ); } }while(0)
#define BEEP(note, time)		do{ beep(note); beep_time = time; }while(0)
//#define BEEP(note, time)		do{}while(0)



/* 複数音を使うやつ */
#define	BEEP_TARGET		(0)
#define	BEEP_STATE		(0)
#define	BEEP_INTEG		(0)

/* 単音 */
#define BEEP_DAKOU			(Def_C4)
#define BEEP_EDGE			(Def_C3)
#define BEEP_NORMAL			(OFF)
#define BEEP_HISPEED		(OFF)

#define BEEP_DAKOU_START	(OFF)
#define BEEP_EDGE_START		(OFF)
#define BEEP_HISPEED_START	(OFF)
#define BEEP_HISPEED_END	(OFF)





#define CENTER	(4)
#define	DISTANCE(x)	distance_def[CENTER+x]
#define	SATURATE( in, upper, lower )	(in > upper) ? upper : (in < lower) ? lower : in

#define SPEED_HI	(700)
#define SPEED_DR	(400)
#define SPEED_LO	(250)

#define	POWER_MIN	(30)
#define	POWER_MAX	(70)

#define Tcool	(500)	// Cooldown time (ms)
#define Tup		(200)	// Power up time (ms)
#define	Tdown	(500)	// Power down time (ms)
#define Ttyoku	(1000)	// 直角検出時のPower down time (ms)
#define	Tooc	(1000)	// コースを外れて止まるまでの時間 (ms)

#define	THup	(1500)	// 速度アップのしきい値(積分)
#define THdown	(3000)	// 速度ダウンのしきい値(積分)


#define myabs(x)	((x) >= 0 ? (x) : -(x))

#define	THdakou	(400)	// 蛇行検出用の値(積分値が一定異常で横にふれていると判断)


#define	DAKOU_MAX	(V_O_RATIO)
int	dakou_left_log[DAKOU_MAX] = {};
int	dakou_right_log[DAKOU_MAX] = {};
int dakou_ptr = 0;

#define	COOLDOWN_TIME	(3)	// n * OPERATION_PERIOD
#define	HISPEED_TIME	(2)		// n * OPERATION_PERIOD

int hispeed  = 0;
int cooldown = COOLDOWN_TIME;

#define		STATE_NORMAL	(0)
#define		STATE_DAKOU		(1)
#define		STATE_EDGE		(2)
#define		STATE_HISPEED	(3)


//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------

unsigned char position;
int distance_def[9] = { -1024, -672, -416, -160, 0, 160, 416, 672, 1024 };

float	Kv[] = { 0.007F, 0.0F, 0.0F };
float	Kl[] = { 0.06F,  0.2F, 0.003F };

float	fKp = 0;
float	fKd = 0;
float	fKi = 0;

int	left_side = 0;
int right_side = 0;

int Detect_dakou = 0;	// 蛇行検出
int Detect_edge  = 0;	// ラインの端っこにいる
int Target_Speed = SPEED_DR;


int power_log[O_C_RATIO] = {};
int	power_off = 0;

int Power = POWER_MIN;
int Speed = 0, Speed_p;
int Dist, Dist_p;

int	sign1_filter[3][4] = {
	0,	 1,	  0,   1,
	0,   1,   1,   0,
	1,   0,   1,   0
};


int pid_float( int dist, int diff, int intg )
{
	int p, i, d;

	p = (int)( fKp * (float)dist );
	d = (int)( fKd * (float)diff );
	i = (int)( fKi * (float)intg );
		
	// output motor		
	return( p+d+i );
}

void   timer_main( int position )
{
    static int dist_p = 0;
    static int intg   = 0;
    int dist;
	int i, j;

    // 制御周期だったら、積分値を送信する
    if( cont_flag > 0 ){
        resp_intg = intg;
        intg = 0;
    }

    // 区間積分値
    dist   = DISTANCE(position);
    intg  += (( dist + dist_p )>>1);
	
    dist_p = dist;

	if( dist > THdakou ){
		right_side++;
	}else if( dist < -THdakou ){
		left_side++;
	}

	// L3,R3より外だったら緊急減速
	if( (position>=3) || (position<=-3) ){
		Detect_edge = 1;
		Target_Speed = SPEED_LO;
	}else{
		Detect_edge = 0;
	}

	


	return;
}


int dv, dl, vr, vl;
int Pr, Di, In;

void    control_main( int position )
{
	int i;
	int	Kpow;
	int max;
		
	//====================================================
	//  縦方向の制御	
	//====================================================
	// 過去の出力Powerから擬似的な速度を算出
	// Target_Speed指示は0-1000の値で与えるので、
	// 算出Speedも最大値が1000になるように補正する
	
	Speed = 0;
	for( i=0; i<O_C_RATIO; i++ ){
		Speed = Speed + power_log[i];
	}
#define	SPEED_RATIO		((100*O_C_RATIO)/1000)
#if SPEED_RATIO != 1
	Speed = Speed / SPEED_RATIO;
#endif
	Speed = SATURATE( Speed, 1000, 0 );

	// 今回のSpeed制御値
	Pr = Target_Speed - Speed;
	if( myabs( Pr ) == 0 ){
		dv = 0;
	}else if( myabs( Pr )<100 ){
		dv = 1;
	}else if( myabs( Pr )<200 ){
		dv = 2;
	}else{
		dv = 3;
	}
	if( Pr < 0 ){
		dv = -dv;
	}

	//====================================================
	//  横方向の制御
	//====================================================
	Dist = DISTANCE(position);
	Pr = Dist;

	// 接近速度での制御（微分）
	Di = Dist - Dist_p;

	// カーブ追従（積分）
	for( i=O_C_RATIO-1; i>0; i-- ){
		intg_log[i] = intg_log[i-1];
	}
	intg_log[0] = resp_intg / C_T_RATIO;

	In = 0;
	for( i=1; i<O_C_RATIO; i++ ){
		In = In + ((intg_log[i]+intg_log[i-1])>>1);
	}

#if BEEP_INTEG > 0
	        if( myabs(In) < 1000 ){
		BEEP( Def_C3, 10 );
	}else 	if( myabs(In) < 2000 ){
		BEEP( Def_D3, 10 );
	}else 	if( myabs(In) < 3000 ){
		BEEP( Def_E3, 10 );
	}else 	if( myabs(In) < 4000 ){
		BEEP( Def_F3, 10 );
	}else{
		BEEP( Def_G3, 10 );
	}		
#endif


	// PID
	fKp = Kl[0];
	fKd = Kl[1];
	fKi = Kl[2];	
	dl = pid_float( Pr, Di, In );
	dl = SATURATE( dl, 100, -100 );

	//====================================================
	//  左右のバランス
	//====================================================
	vl = 100;
	vr = 100;

	// balancing
	if( dl > 0 ){
		vr = vr - myabs( dl );
	}else if( dl < 0 ){
		vl = vl - myabs( dl );
	}
	vl = SATURATE( vl, 100, 0 );
	vr = SATURATE( vr, 100, 0 );
	
	//====================================================
	//  車速の調整
	//====================================================
	Power = Power + dv;
	Power = SATURATE( Power, POWER_MAX, POWER_MIN );
	vl = ( Power * vl ) / 100;
	vr = ( Power * vr ) / 100;

	// パワーオフ指示
	if( power_off ){
		vl = 0;
		vr = 0;
	}

	//====================================================
    //  モータ出力
	//====================================================
	vl = SATURATE( vl, 100, 0 );
	vr = SATURATE( vr, 100, 0 );
	motor( vl, vr );

	//====================================================
    //  次の周期へのデータ保存
	//====================================================
    Dist_p  = Dist;
	Speed_p = Speed;

	// Powerの累積
	for( i=O_C_RATIO-1; i>0; i-- ){
		power_log[i] = power_log[i-1];
	}
	power_log[0] = Power;

	return;
}


void    operation_main( void )
{
	int	i;
	static int state   = STATE_NORMAL;
	static int state_p = STATE_NORMAL;

	// 蛇行検出用ログ
	dakou_left_log[dakou_ptr]  = left_side;
	dakou_right_log[dakou_ptr] = right_side;
	dakou_ptr ++;
	dakou_ptr = dakou_ptr % DAKOU_MAX;
	left_side  = 0;
	right_side = 0;
	
	// State
	if( Detect_dakou ){
		state = STATE_DAKOU;
	}else if( Detect_edge ){
		state = STATE_EDGE;
	}else if( (cooldown==0)&&(hispeed==0) ){
		state = STATE_HISPEED;
		hispeed = HISPEED_TIME;
	}else if( hispeed==0 ){
		state = STATE_NORMAL;
	}

#if BEEP_NORMAL > 0
	if(state==STATE_NORMAL){
		BEEP( BEEP_NORMAL, 20 );
	}		
#endif
#if BEEP_DAKOU > 0
	if(state==STATE_DAKOU){
		BEEP( BEEP_DAKOU, 20 );
	}		
#endif
#if BEEP_EDGE > 0
	if(state==STATE_EDGE){
		BEEP( BEEP_EDGE, 20 );
	}		
#endif


#if BEEP_STATE > 0
	if(state==STATE_DAKOU){
		BEEP( Def_C3, 20 );
	}else if(state==STATE_EDGE){
		BEEP( Def_G3, 20 );
	}else if(state==STATE_HISPEED){
		BEEP( Def_C4, 20 );
	}
#endif


	// State変化
	if( (state_p!=STATE_DAKOU)&&(state==STATE_DAKOU) ){
#if BEEP_DAKOU_START > 0
	BEEP( BEEP_DAKOU_START, 50 );
#endif
	}
	if( (state_p!=STATE_EDGE)&&(state==STATE_EDGE) ){
#if BEEP_EDGE_START > 0
	BEEP( BEEP_EDGE_START, 50 );
#endif
	}
	if( (state_p!=STATE_HISPEED)&&(state==STATE_HISPEED) ){
		cooldown = COOLDOWN_TIME + HISPEED_TIME;
#if BEEP_HISPEED_START > 0
	BEEP( BEEP_HISPEED_START, 50 );
#endif
	}
	if( (state_p==STATE_HISPEED)&&(state!=STATE_HISPEED) ){
#if BEEP_HISPEED_END > 0
	BEEP( BEEP_HISPEED_END, 50 );
#endif
	}

	// 速度指令
	if( (state==STATE_DAKOU) || (state==STATE_EDGE)){
		Target_Speed = SPEED_LO;
	}else if( (state==STATE_HISPEED) ){
		Target_Speed = SPEED_HI;
	}else{
		Target_Speed = SPEED_DR;
	}

#if BEEP_TARGET > 0
	if( Target_Speed == SPEED_LO ){
		BEEP( Def_C3, 20 );
	}else if( Target_Speed == SPEED_DR ){
		BEEP( Def_G3, 20 );
	}else if( Target_Speed == SPEED_HI ){
		BEEP( Def_C4, 20 );
	}		
#endif


	//====================================================
    //  次の周期へのデータ保存／更新
	//====================================================
	if( hispeed > 0 ){
		hispeed--;
	}
	if( cooldown > 0 ){
		cooldown--;
	}
	state_p = state;

	return;
}

void	vehicle_main( void )
{
	int i;
	int left, right;
	
	right = 0;
	left  = 0;
	for( i=0; i<DAKOU_MAX; i++ ){
		right += dakou_right_log[i];
		left  += dakou_left_log[i];
	}
	if( (right>0) && (left>0) ){
		Detect_dakou = 1;
	}else{
		Detect_dakou = 0;
	}
	
}

void main(void)
{
	unsigned char sensor_val;
    int position, position_p;

	DI();
	if( (_flg_ & 0x02) == 0 ){
		clock_init();
	}
	peri_init();
	EI();

#if 0
	while( pushsw() == 0 );	// スタートボタン押下待ち
    timer( 0, 100 );
	while( pushsw() != 0 );	// スタートボタン開放待ち
#endif

    while(1){
        position_p = position;
		sensor_val  = sensor_check();		// ラインセンサーから最新情報を取得

        switch( sensor_val ){
            case SENSOR_LR0:	position =  0; break;
            case SENSOR_L1 :	position = -1; break;
            case SENSOR_L2 :	position = -2; break;
            case SENSOR_L3 :	position = -3; break;
            case SENSOR_LC :	position = -4; break;
            case SENSOR_R1 :	position = +1; break;
            case SENSOR_R2 :	position = +2; break;
            case SENSOR_R3 :	position = +3; break;
            case SENSOR_RC :	position = +4; break;
            case SENSOR_AB :	position = position_p; break;
            default :
                if( position_p > 0 ){
                    position = +4;
                } else if( position_p < 0 ){
                    position = -4;
                } else {
                    position = 0;
                }
                break;
        }

        if( timer_flag > 0 ){
			timer_main( position );
            timer_flag = 0;
        }
        if( cont_flag > 0 ){
            control_main( position );
            cont_flag = 0;
        }
        if( opr_flag > 0 ){
			operation_main();
            opr_flag = 0;
        }
		if( veh_flag > 0 ){
			vehicle_main();
			veh_flag = 0;
		}
		
		// ビープ出力の停止
		BEEP_PERIOD();
	}

}


//------------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------------
