/***********************************************************************/
/*                                                                     */
/*  FILE        :MiconRacer2.c                                         */
/*  DATE        :Sat, Nov 14, 2015                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :34C                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include <stdlib.h>
#include "mr2_lib.h"

#pragma CREG	_flg_	flg
unsigned int	_flg_;

#define	INTG_MAX		(OPERATION_PERIOD/CONTROL_PERIOD)
int intg_log[INTG_MAX] = {};
int intg_ptr = 0;
#define INTG_PUSH(x)	do{ intg_log[intg_ptr++] = x; intg_ptr %= INTG_MAX; }while(0)

int timer_flag;
int cont_flag;
int opr_flag;
int veh_flag;

int resp_intg;      // CONTROL_PERIOD区間の距離の積分値

#define BEEP_MAX	(100)		// ビープの長さ (ms)
#define BEEP(x)		beep(x)
//#define BEEP(x)		do{}while(0)

#define	BEEP_DAKOU		Def_C3

#define CENTER	(4)
#define	DISTANCE(x)	distance_def[CENTER+x]
#define	SATURATE( in, upper, lower )	(in > upper) ? upper : (in < lower) ? lower : in

#define	POWER_HALF (int)((float)500 * (50.0F/(float)MOTOR_LIMIT))
#define	POWER_SLOW (int)((float)750 * (50.0F/(float)MOTOR_LIMIT))

#define Dup		(2)		// 加速時Power増分
#define Ddown	(4)		// 減速時Power増分

#define Tcool	(500)	// Cooldown time (ms)
#define Tup		(200)	// Power up time (ms)
#define	Tdown	(500)	// Power down time (ms)
#define Ttyoku	(1000)	// 直角検出時のPower down time (ms)
#define	Tooc	(1000)	// コースを外れて止まるまでの時間 (ms)

#define	THup	(1500)	// 速度アップのしきい値(積分)
#define THdown	(3000)	// 速度ダウンのしきい値(積分)


#define myabs(x)	((x) >= 0 ? (x) : -(x))

//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------

unsigned char position;
int distance_def[9] = { -1024, -672, -416, -160, 0, 160, 416, 672, 1024 };

float	Kv[] = { 0.03F,	0.0F,	0.0F };
float	Kl[] = { 0.04F,	0.025F,	0.0005F };

float	fKp = 0;
float	fKd = 0;
float	fKi = 0;

//float	fKp = 0.0001F;
//float	fKd = 0.17F;
//float	fKi = 0.01F;

//float	fKp = 0.0002F;
//float	fKd = 0.03F;
//float	fKi = 0.005F;

int pid_float( int dist, int diff, int intg )
{
	int p, i, d;

	p = (int)( fKp * (float)dist );
	d = (int)( fKd * (float)diff );
	i = (int)( fKi * (float)intg );
		
	// output motor		
	return( p+d+i );
}

int	ool = 0;
int oor = 0;

#define	THdakou	(1000)	// 蛇行検出用の値(積分値が一定異常で横にふれていると判断)

void   timer_main( int position )
{
    static int dist_p = 0;
    static int intg   = 0;
    int dist;

    // 制御周期だったら、積分値を送信する
    if( cont_flag > 0 ){
        resp_intg = intg;
        intg = 0;
    }

    // 区間積分値
    dist   = DISTANCE(position);
    intg  += (( dist + dist_p )>>1);
	
    dist_p = dist;

	if( dist > THdakou ){
		oor++;
	}else if( dist < -THdakou ){
		ool++;
	}	

	return;
}

#define	C_T_RATIO	(CONTROL_PERIOD   / TIMER_PERIOD    )
#define	O_C_RATIO	(OPERATION_PERIOD / CONTROL_PERIOD  )
#define	V_O_RATIO	(VEHICLE_PERIOD   / OPERATION_PERIOD)

int Target_speed = 500;
int power_log[O_C_RATIO] = {};
int	power_off = 0;
int State_dakou = 0;
int State_cool = 0;
int State_ooc = 0;
int Power = 0;
int Speed, Speed_p;
int Dist, Dist_p;

void    motor_control( int position )
{
	int i;
	int	Kpow;
    int Pr, Di, In;
    int dv, dl, vr, vl;
		
	//====================================================
	//  縦方向の制御	
	//====================================================
	// Powerから擬似的な速度を算出
	Kpow  = 100;
	Speed = 0;
	for( i=0; i<O_C_RATIO; i++ ){
		Speed = Speed + Kpow * power_log[i];
		Kpow  = Kpow - Kpow/O_C_RATIO;
	}
	Speed = Speed / 100;

	// 今回のSpeed制御値
	Pr = Target_speed - Speed;
	Di = Speed - Speed_p;
	In = ( Speed + Speed_p ) >> 1;

	fKp = Kv[0];
	fKd = Kv[1];
	fKi = Kv[2];	
	dv = pid_float( Pr, Di, In )/10;
	dv = SATURATE( dv, 3, -5 );

	//====================================================
	//  横方向の制御
	//====================================================
	Dist = DISTANCE(position);
	Pr = Dist;

	// 接近速度での制御（微分）
	Di = Dist - Dist_p;

	// カーブ追従（積分）
	In = resp_intg;
	INTG_PUSH( In );

	// PID
	fKp = Kl[0];
	fKd = Kl[1];
	fKi = Kl[2];	
	dl = pid_float( Pr, Di, In );
	dl = SATURATE( dl, 100, -100 );

	//====================================================
	//  左右のパワー決め
	//====================================================
	Power = Power + dv;
	Power = SATURATE( Power, 100, 0 );
	
	vr = Power;
	vl = Power;

	// balancing
	if( dl > 0 ){
		vr = vr - 2*dl;
		vl = vl - dl;
	}else if( dl < 0 ){
		vr = vr + 2*dl;
		vl = vl + dl;
	}

	// パワーオフ指示
	if( power_off ){
		vr = 0;
		vl = 0;
	}

    // モータ出力
	vr = SATURATE( vr, 100, 0 );
	vl = SATURATE( vl, 100, 0 );
	motor( vl, vr );

    // 保存
    Dist_p  = Dist;
	Speed_p = Speed;

	// Powerの累積
	for( i=O_C_RATIO-1; i>0; i-- ){
		power_log[i] = power_log[i-1];
	}
	power_log[0] = Power+(dl>>1);

	return;
}

#define	DAKOU_MAX	(V_O_RATIO*2)

int	dakou_log[DAKOU_MAX] = {};
int dakou_ptr = 0;

void    operation_main( void )
{
	int	i;
	int lineout;

	// 蛇行検出用ログ
	dakou_log[(dakou_ptr<<1)]   = oor;
	dakou_log[(dakou_ptr<<1)+1] = ool;

	dakou_ptr += 2;
	dakou_ptr %= DAKOU_MAX;

	// ラインずれ検出
	for( i=0; i<O_C_RATIO; i++ ){
		lineout += intg_log[i];
	}			

	// 速度指令
	if( State_cool ){
		Target_speed = 250;
	}else if( State_dakou ){
		Target_speed = 250;
	}else{
		Target_speed = 700;
	}

	return;
}

void	vehicle_main( void )
{
	int i;
	int left, right;
	
	right = 0;
	left  = 0;
	for( i=0; i<(DAKOU_MAX/2); i++ ){
		right += dakou_log[(i<<1)  ];
		left  += dakou_log[(i<<1)+1];
	}
	if( (right>0) && (left>0) ){
		State_dakou = 1;
	}else{
		State_dakou = 0;
		State_cool  = 100;
	}
	
}

void main(void)
{
	unsigned char sensor_val;
    int position, position_p;

	DI();
	if( (_flg_ & 0x02) == 0 ){
		clock_init();
	}
	peri_init();
	EI();

#if 0
	while( pushsw() == 0 );	// スタートボタン押下待ち
    timer( 0, 100 );
	while( pushsw() != 0 );	// スタートボタン開放待ち
#endif

    while(1){
        position_p = position;
		sensor_val  = sensor_check();		// ラインセンサーから最新情報を取得

        switch( sensor_val ){
            case SENSOR_LR0:	position =  0; break;
            case SENSOR_L1 :	position = -1; break;
            case SENSOR_L2 :	position = -2; break;
            case SENSOR_L3 :	position = -3; break;
            case SENSOR_LC :	position = -4; break;
            case SENSOR_R1 :	position = +1; break;
            case SENSOR_R2 :	position = +2; break;
            case SENSOR_R3 :	position = +3; break;
            case SENSOR_RC :	position = +4; break;
            case SENSOR_AB :	position = position_p; break;
            default :
                if( position_p > 0 ){
                    position = +4;
                } else if( position_p < 0 ){
                    position = -4;
                } else {
                    position = 0;
                }
                break;
        }

        if( timer_flag > 0 ){
			timer_main( position );
            timer_flag = 0;
        }
        if( cont_flag > 0 ){
            motor_control( position );
            cont_flag = 0;
        }
        if( opr_flag > 0 ){
			operation_main();
            opr_flag = 0;
        }
		if( veh_flag > 0 ){
			veh_flag = 0;
		}
	}

}


//------------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------------
