/***********************************************************************/
/*                                                                     */
/*  FILE        :MiconRacer2.c                                         */
/*  DATE        :Sat, Nov 14, 2015                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :34C                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include <stdlib.h>
#include "mr2_lib.h"

#pragma CREG	_flg_	flg
unsigned int	_flg_;

#define	POS_MAX		(30)
int pos_log[POS_MAX] = {};

#define DAKOU_MAX	(15)
int	dakou_log[DAKOU_MAX] = {};
int dakou_ptr = 0;
#define DAKOU_PUSH(x)	do{ dakou_log[dakou_ptr++] = x; dakou_ptr %= DAKOU_MAX; }while(0)

#define BEEP_MAX	(100)
#define BEEP(x)		beep(x)
//#define BEEP(x)		do{}while(0)


#define	BEEP_LOGERR		OFF
#define	BEEP_TOBI		OFF
#define	BEEP_DAKOU		Def_C4
#define	BEEP_POWLOW		OFF
#define BEEP_POWMAX		OFF

#define CENTER	(4)
#define	DISTANCE(x)	distance_def[CENTER+pos_log[x]]
#define	SATURATE( in, upper, lower )	(in > upper) ? upper : (in < lower) ? lower : in

#define	POWER_HALF (int)((float)500 * (50.0F/(float)MOTOR_LIMIT))
#define	POWER_SLOW (int)((float)750 * (50.0F/(float)MOTOR_LIMIT))

#define SCALING		(20)
#define myabs(x)	((x) >= 0 ? (x) : -(x))

//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------

long long int Kp = 210;
long long int Kd = 31457;
long long int Ki = 5243;

long long int p, i, d;
long long int fx_dist, fx_diff, fx_intg;

float	fKp = 0.0002F;
float	fKd = 0.03F;
float	fKi = 0.005F;

int pid_float( int dist, int diff, int intg )
{
	int p, i, d;

	p = (int)( fKp * (float)dist * (float)myabs(dist) );
	d = (int)( fKd * (float)diff );
	i = (int)( fKi * (float)intg );
		
	// output motor		
	return( p+d+i );
}

int pid( int dist, int diff, int intg )
{
	
	fx_dist = ((long long int)dist) << SCALING;
	fx_diff = ((long long int)diff) << SCALING;
	fx_intg = ((long long int)intg) << SCALING;
	
	p = ( Kp * (( fx_dist * myabs(fx_dist)) >> SCALING )) >> SCALING;
	d = ( Kd * fx_diff ) >> SCALING;
	i = ( Ki * fx_intg ) >> SCALING;
	
	return( (int)((p+i+d)>>SCALING) );
}

void run_main( void )
{
	unsigned char read_line = 0;
	int i;
	int cyc_cnt;
	int	ooc;
	int	oop;
	int	pos;

	int distance_def[9] = { -1024, -672, -416, -160, 0, 160, 416, 672, 1024 };
	int dv, vr, vl;
	int dist, diff, intg;

	int tobi, dakou, instab;
	int pole, side_r, side_l;
	int	dakou_intg;
	
	int beep_count;
	int error;
	int power_down, power_up, power_off;
	int	power;

	ooc = 0;
	beep_count = 0;
	power = 100;
	cyc_cnt = 0;
	dakou_intg = 0;
    while(1){		
		read_line = sensor_check();		// ラインセンサーから最新情報を取得

		// position log
		error = 0;
		for( i=POS_MAX-1; i>0; i-- ){
			pos_log[i] = pos_log[i-1];
			     if( pos_log[i] >  1024 ){ error = 1; }
			else if( pos_log[i] < -1024 ){ error = 1; }
		}
#if BEEP_LOGERR > 0
		if( error ){
			BEEP( BEEP_LOGERR );
			beep_count = BEEP_MAX;
		}
#endif

		switch( read_line ){
			case SENSOR_LR0:	pos =  0; ooc = 0;	break;
			case SENSOR_L1 :	pos = -1; ooc = 0;	break;
			case SENSOR_L2 :	pos = -2; ooc = 0;	break;
			case SENSOR_L3 :	pos = -3; ooc = 0;	break;
			case SENSOR_LC :	pos = -4; ooc = 0;	break;
			case SENSOR_R1 :	pos = +1; ooc = 0;	break;
			case SENSOR_R2 :	pos = +2; ooc = 0;	break;
			case SENSOR_R3 :	pos = +3; ooc = 0;	break;
			case SENSOR_RC :	pos = +4; ooc = 0;	break;
			case SENSOR_AB :	pos = pos_log[1]; ooc = 0; break;
			default :
				if( pos_log[1] > 0 ){
					pos = +4;
				} else if( pos_log[1] < 0 ){
					pos = -4;
				} else {
					pos = 0;
				}
				ooc++;
				break;
		}
		pos_log[0] = pos;

		// 安定性の評価
		
		// センサ飛び検出
		tobi = (myabs(pos_log[0]-pos_log[1])>1);
#if BEEP_TOBI > 0
		if( tobi > 0 ){
			BEEP( BEEP_TOBI );
			beep_count = BEEP_MAX;
		}
#endif
		
		// 蛇行検出
		if( cyc_cnt == 0 ){
			DAKOU_PUSH( dakou_intg );
			dakou_intg = 0;

			dakou = 0;		
			pole  = 0;
			for (i=0; i<DAKOU_MAX-1; i++ ){
				side_r = ((dakou_log[i]/POS_MAX)<<1) >  3;
				side_l = ((dakou_log[i]/POS_MAX)<<1) < -3;
			
				if( pole == 1 ){
					if( side_r ){ pole =  1;          }
					if( side_l ){ pole = -1; dakou++; }
				}else if ( pole == -1 ){
					if( side_r ){ pole =  1; dakou++; }
					if( side_l ){ pole = -1;          }
				}else{
					if( side_r ){ pole =  1;          }
					if( side_l ){ pole = -1;          }
				}
			}
		}
		dakou_intg += pos;

#if BEEP_DAKOU > 0
		if( dakou > 0 ){
			BEEP( BEEP_DAKOU );
			beep_count = BEEP_MAX;
		}
#endif
		
		// 距離での制御
		dist = DISTANCE(0);
		
		// 接近速度での制御（微分）
		diff = DISTANCE(0)-DISTANCE(1);

		// カーブ追従（積分）
		intg =	((DISTANCE(0)+DISTANCE(1))>>1) +
				((DISTANCE(1)+DISTANCE(2))>>1) +
				((DISTANCE(2)+DISTANCE(3))>>1) +
				((DISTANCE(3)+DISTANCE(4))>>1) +
				((DISTANCE(4)+DISTANCE(5))>>1);

		// PID
		dv = pid_float( dist, diff, intg );
//		dv = pid( dist, diff, intg );
		SATURATE( dv, 100, -100 );

		// パワーダウン指示
		power_down = (dakou>0) || (myabs(intg)>3000);
		power_up   = (myabs(intg)<1500);
		
		// 出力調整
		if( power_down ){
			power -= 4;
		}else if( power_up ){
			power += 1;
		}
		if( myabs(dist) > 700 ){
			power = SATURATE( power, 1000, POWER_HALF );
		}else{
			power = SATURATE( power, 1000, POWER_SLOW );
		}
		
#if BEEP_POWLOW > 0
		if( power < POWER_SLOW ){
			BEEP( BEEP_POWLOW );
			beep_count = BEEP_MAX;
		}
#endif
#if BEEP_POWMAX > 0
		if( power >= 1000 ){
			BEEP( BEEP_POWMAX );
			beep_count = BEEP_MAX;
		}
#endif
		
		vr = power/10;
		vl = power/10;

		// balancing
		if( dv > 0 ){
			vr = vr - dv;
		}else if( dv < 0 ){
			vl = vl + dv;
		}
		vr = SATURATE( vr, 100, 0 );
		vl = SATURATE( vl, 100, 0 );

		// パワーオフ指示
		power_off = ooc > 500;
		if( power_off ){
			vr = 0;
			vl = 0;
		}

		motor( vl, vr );
		
		// Beep 停止
		beep_count--;
		if( beep_count <= 0 ){
			BEEP( 0 );
		}
		
		cyc_cnt = (cyc_cnt+1) % POS_MAX;
			

	}	// while(1)

	return;
}

void main(void)
{
	DI();
	if( (_flg_ & 0x02) == 0 ){
		clock_init();
	}
	peri_init();
	EI();

	//while( pushsw() == 0 );	// スタートボタン押下待ち
	run_main();
}


//------------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------------
