/***********************************************************************/
/*                                                                     */
/*  FILE        :MiconRacer2.c                                         */
/*  DATE        :Sat, Nov 14, 2015                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :34C                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include <stdlib.h>
#include "mr2_lib.h"

#pragma CREG	_flg_	flg
unsigned int	_flg_;

#define BEEP(x)		mr2_beep(x)
//#define BEEP(x)		do{}while(0)

	
//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------
int pos_log[POS_MAX];

void run_main( void )
{
	unsigned char read_line = 0;
	int i;
	int	ooc;
	int	oop;
	int	pos;

#define CENTER	(4)
#define	DISTANCE(x)	distance_def[CENTER+pos_log[x]]

	int distance_def[9] = { -1024, -672, -416, -160, 0, 160, 416, 672, 1024 };
	int dv, vr, vl;
	int dist, diff, intg;
	int	p_factor, i_factor, d_factor, r_factor;
	float coeff[3];
	volatile float tmp1, tmp2, tmp3;

	int tobi, dakou, instab;
	int side_l, side_r;
	
	int error;
	
	ooc = 0;
    while(1){		
		read_line = mr2_sensor_check();		// ラインセンサーから最新情報を取得

		// position log
		error = 0;
		for( i=POS_MAX-1; i>0; i-- ){
			pos_log[i] = pos_log[i-1];
			     if( pos_log[i] >  1024 ){ error = 1; }
			else if( pos_log[i] < -1024 ){ error = 1; }
		}
		if( error ){
			BEEP(Def_F3);
		}else{
			BEEP(0);
		}

		switch( read_line ){
			case SENSOR_LR0:	pos =  0; ooc = 0;	break;
			case SENSOR_L1 :	pos = -1; ooc = 0;	break;
			case SENSOR_L2 :	pos = -2; ooc = 0;	break;
			case SENSOR_L3 :	pos = -3; ooc = 0;	break;
			case SENSOR_R1 :	pos = +1; ooc = 0;	break;
			case SENSOR_R2 :	pos = +2; ooc = 0;	break;
			case SENSOR_R3 :	pos = +3; ooc = 0;	break;
			case SENSOR_AW :
				if( pos_log[1] > 0 ){
					pos = +4;
				} else if( pos_log[1] < 0 ){
					pos = -4;
				} else {
					pos = 0;
				}
				ooc++;
				break;
			default :
				pos = 0;
				ooc++;
				break;
		}
		pos_log[0] = pos;

		// 安定性の評価
		
		// センサ飛び検出
		tobi = 0;
		for (i=1; i<POS_MAX-1; i++ ){
			tobi += (abs(pos_log[i]-pos_log[i-1])>1);
		}
		
		// 蛇行検出
		side_l = 0;
		side_r = 0;
		for (i=0; i<POS_MAX-1; i++ ){
			if( pos_log[i] < -2 ){
				side_l = 1;
			}
			if( pos_log[i] > 2 ){
				side_r = 1;
			}
		}
		dakou = 0;
		if( (side_l==1) && (side_r==1) ){
			dakou = 1;
		}
		
		//tobi=0;
		dakou=0;
		// 速度制限
		if( (tobi==0) && (dakou==0) ){
			instab = 0;
		}else{
			instab++;
		}
	
		// 距離での制御
		dist = DISTANCE(0);
		
		// 接近速度での制御（微分）
		diff = DISTANCE(0)-DISTANCE(1);

		// カーブ追従（積分）
		intg =	((DISTANCE(0)-DISTANCE(1))>>1) +
				((DISTANCE(1)-DISTANCE(2))>>1) +
				((DISTANCE(2)-DISTANCE(3))>>1) +
				((DISTANCE(3)-DISTANCE(4))>>1) +
				((DISTANCE(4)-DISTANCE(5))>>1);

		// PID
		coeff[0] = 0.0625F;
		coeff[1] = 0;
		coeff[2] = 0;
//		coeff[2] = 0.0625;

		tmp1 = 0.02F;
		tmp2 = 0.01F;
		tmp3 = tmp1 * tmp2;
		p_factor = 0;
		d_factor = 0;
		i_factor = 0;
//		p_factor = (int)(( 0.01F * ((float)dist) ) * ( 0.01F * ((float)(abs(dist))) ) * 2.0F);
//		d_factor = (int)(coeff[1] * ((float)diff));
//		i_factor = (int)(coeff[2] * ((float)intg));
		
		// output motor		
		dv = p_factor + d_factor + i_factor;

		// saturation
		if( dv > 100 ){ dv = 100; }
		if( dv <-100 ){ dv =   0; }

		// balancing
		if( dv > 0 ){
			vr = 100 - dv;
			vl = 100;
		}else if( dv < 0 ){
			vr = 100;
			vl = 100 + dv;
		}else{
			vr = 100;
			vl = 100;
		}

		// パワーダウン指示
		if( instab>10 ){
			vr = 0.5 * vr;
			vl = 0.5 * vl;
			//BEEP( Def_C4 );
		}else{
			//BEEP( 0 );			
		}

		// パワーオフ指示
		if( ooc>500 ){
			vr = 0;
			vl = 0;
		}
		
		if( vr > 100 ){ vr = 100; }
		if( vr <-100 ){ vr =   0; }
		if( vl > 100 ){ vl = 100; }
		if( vl <-100 ){ vl =   0; }

		mr2_motor( vl, vr );

	}	// while(1)

	return;
}

void main(void)
{
	DI();
	if( (_flg_ & 0x02) == 0 ){
		mr2_clock_init();
	}
	mr2_peri_init();
	EI();

	//while( mr2_pushsw() == 0 );	// スタートボタン押下待ち
	
	run_main();
}


//------------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------------
